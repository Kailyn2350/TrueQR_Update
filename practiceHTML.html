<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Animated Gradient Login</title>
    <style>
        :root {
            --primary: #7c4dff;
            --accent: #00e5ff;
            --bg1: #0f1226;
            --bg2: #1a1440;
            --card: rgba(255, 255, 255, .10);
            --text: #eef2ff;
            --muted: #b4b8d4;
            --radius: 18px;
            --shadow: 0 20px 60px rgba(0, 0, 0, .35);
            --border: rgba(255, 255, 255, .18);
            /* 마우스 하이라이트 위치 변수 */
            --mx: 50%;
            --my: 50%;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            min-height: 100svh;
            color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Apple SD Gothic Neo, "맑은 고딕", sans-serif;
            overflow: hidden;
            /* 애니메이션 캔버스 스크롤 방지 */
        }

        /* === 1) 그라데이션이 계속 변하는 메인 배경 === */
        .bg-gradient {
            position: fixed;
            inset: 0;
            z-index: -3;
            background:
                radial-gradient(1200px 700px at 15% 0%, rgba(124, 77, 255, .35), transparent 60%),
                radial-gradient(900px 600px at 110% 30%, rgba(0, 229, 255, .25), transparent 60%),
                linear-gradient(140deg, var(--bg1), #1a1440, #111a3a, var(--bg2));
            background-size: 120% 120%, 120% 120%, 300% 300%;
            animation: gradShift 20s ease-in-out infinite alternate;
            filter: saturate(120%);
        }

        @keyframes gradShift {
            0% {
                background-position: 0% 0%, 100% 30%, 0% 50%;
            }

            50% {
                background-position: 20% 5%, 70% 40%, 60% 60%;
            }

            100% {
                background-position: 35% 12%, 50% 55%, 100% 50%;
            }
        }

        /* === 2) 마우스 따라다니는 하이라이트(스포트라이트) ===
       CSS 변수 --mx / --my 로 중심을 이동시키는 가벼운 레이어 */
        .bg-spotlight {
            position: fixed;
            inset: -10%;
            z-index: -2;
            pointer-events: none;
            background:
                radial-gradient(500px 500px at var(--mx) var(--my),
                    rgba(255, 255, 255, .16), rgba(255, 255, 255, .04) 35%, transparent 60%);
            transition: background-position .05s linear;
            /* 미세 스무딩 */
            mix-blend-mode: screen;
            filter: blur(6px);
        }

        /* === 3) 파티클 캔버스 (마우스 반응 + 패럴랙스) === */
        canvas#particles {
            position: fixed;
            inset: 0;
            z-index: -1;
            pointer-events: none;
        }

        /* 중앙 레이아웃 */
        .container {
            min-height: 100svh;
            display: grid;
            place-items: center;
            padding: clamp(20px, 4vw, 40px);
        }

        h1 {
            margin: 0 0 18px;
            text-align: center;
            font-weight: 800;
            letter-spacing: .3px;
            font-size: clamp(22px, 3.2vw, 32px);
            background: linear-gradient(90deg, #fff, #b7e9ff 40%, #e0d0ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 24px rgba(0, 229, 255, .12);
        }

        p.sub {
            margin: 0 0 26px;
            text-align: center;
            color: var(--muted);
            font-size: 14px;
        }

        .card {
            width: min(420px, 92vw);
            background: var(--card);
            backdrop-filter: saturate(140%) blur(14px);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
            padding: 22px;
            display: grid;
            gap: 18px;
            isolation: isolate;
        }

        .card::before {
            content: "";
            position: absolute;
            inset: -1px;
            background: linear-gradient(140deg, rgba(124, 77, 255, .65), rgba(0, 229, 255, .65), transparent 60%);
            border-radius: calc(var(--radius) + 2px);
            filter: blur(30px);
            opacity: .35;
            z-index: -1;
        }

        .field {
            display: grid;
            gap: 8px;
            position: relative;
        }

        /* 플로팅 레이블 */
        .floating {
            position: relative;
        }

        .floating input {
            padding: 16px 44px 14px 14px;
            /* 오른쪽은 토글 아이콘 여유 */
        }

        .floating label {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--muted);
            pointer-events: none;
            transition: all .18s ease;
            background: transparent;
            padding: 0 4px;
        }

        .floating input:focus+label,
        .floating input:not(:placeholder-shown)+label {
            top: 4px;
            font-size: 12px;
            color: #b9ccff;
            backdrop-filter: blur(2px);
        }

        input[type="text"],
        input[type="password"] {
            width: 100%;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .24);
            background: rgba(255, 255, 255, .06);
            color: var(--text);
            outline: none;
            transition: border-color .15s ease, box-shadow .2s ease, background .2s ease;
            font-size: 15px;
        }

        input::placeholder {
            color: transparent;
        }

        /* 플로팅용 */
        input:hover {
            background: rgba(255, 255, 255, .10);
            border-color: rgba(255, 255, 255, .35);
        }

        input:focus {
            border-color: #a7b0ff;
            box-shadow: 0 0 0 3px rgba(124, 77, 255, .20), 0 10px 30px rgba(0, 0, 0, .22);
        }

        .btn {
            width: 100%;
            padding: 14px 16px;
            border: 0;
            border-radius: 14px;
            color: #0e1020;
            font-weight: 800;
            letter-spacing: .3px;
            cursor: pointer;
            background: linear-gradient(135deg, #a08bff, #60e9ff);
            box-shadow:
                inset 0 0 0 1px rgba(255, 255, 255, .35),
                0 10px 28px rgba(96, 233, 255, .26),
                0 6px 18px rgba(160, 139, 255, .22);
            transition: transform .08s ease, filter .15s ease, box-shadow .2s ease;
        }

        .btn:hover {
            filter: brightness(1.05);
            box-shadow:
                inset 0 0 0 1px rgba(255, 255, 255, .45),
                0 14px 36px rgba(96, 233, 255, .34),
                0 8px 22px rgba(160, 139, 255, .28);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .muted {
            color: var(--muted);
            font-size: 13px;
            text-align: center;
        }

        .muted a {
            color: #cfe9ff;
            text-decoration: none;
        }

        .muted a:hover {
            text-decoration: underline;
        }

        /* 비번 토글 버튼 (크고 선명) */
        .pw-wrap {
            position: relative;
        }

        .pw-toggle {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 36px;
            height: 36px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .35);
            background: rgba(255, 255, 255, .10);
            color: #e6ebff;
            display: grid;
            place-items: center;
            cursor: pointer;
            transition: background .15s ease, border-color .15s ease, box-shadow .2s ease, transform .06s ease;
            backdrop-filter: blur(8px) saturate(140%);
            box-shadow: 0 6px 16px rgba(0, 0, 0, .25);
        }

        .pw-toggle:hover {
            background: rgba(255, 255, 255, .16);
            border-color: rgba(255, 255, 255, .55);
            box-shadow: 0 10px 22px rgba(0, 0, 0, .28), 0 0 0 3px rgba(124, 77, 255, .18);
        }

        .pw-toggle:active {
            transform: translateY(-50%) scale(.98);
        }

        .pw-toggle:focus-visible {
            outline: none;
            box-shadow:
                0 0 0 3px rgba(0, 229, 255, .25),
                0 0 0 6px rgba(124, 77, 255, .18);
        }

        .pw-wrap.showing .pw-toggle {
            border-color: #9eb6ff;
            box-shadow:
                0 0 0 3px rgba(124, 77, 255, .22),
                0 10px 28px rgba(96, 233, 255, .22);
            background: linear-gradient(135deg, rgba(160, 139, 255, .22), rgba(96, 233, 255, .18));
        }

        /* 사용자 모션 최소화 설정 시 애니메이션 축소 */
        @media (prefers-reduced-motion: reduce) {
            .bg-gradient {
                animation: none;
            }

            .bg-spotlight {
                transition: none;
            }
        }
    </style>
</head>

<body>
    <!-- 계속 변하는 그라데이션 -->
    <div class="bg-gradient"></div>
    <!-- 마우스 따라다니는 하이라이트 -->
    <div class="bg-spotlight"></div>
    <!-- 반응형 파티클 -->
    <canvas id="particles"></canvas>

    <main class="container">
        <div>
            <h1>Welcome to the Login Page</h1>
            <p class="sub">애니메이티드 그라데이션 + 마우스 반응 하이라이트/파티클 + 글라스 카드</p>

            <form action="login.php" method="post" class="card" novalidate>
                <!-- 아이디 -->
                <div class="field floating">
                    <input type="text" id="username" name="username" autocomplete="username" placeholder=" " required />
                    <label for="username">Username</label>
                </div>

                <!-- 패스워드 + 토글 -->
                <div class="field floating pw-wrap">
                    <input type="password" id="password" name="password" autocomplete="current-password" placeholder=" "
                        required />
                    <label for="password">Password</label>

                    <button type="button" class="pw-toggle" id="togglePw" aria-label="비밀번호 표시 전환" aria-pressed="false"
                        title="Show password">
                        <!-- Open eye -->
                        <svg id="eyeOpen" xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
                            <circle cx="12" cy="12" r="3" />
                        </svg>
                        <!-- Closed eye -->
                        <svg id="eyeClosed" xmlns="http://www.w3.org/2000/svg" width="22" height="22"
                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                            <path d="M17.94 17.94A10.94 10.94 0 0 1 12 20c-7 0-11-8-11-8a21.4 21.4 0 0 1 5.17-6.91" />
                            <path d="M1 1l22 22" />
                            <path d="M9.53 9.53A3.5 3.5 0 0 0 12 16.5 3.5 3.5 0 0 0 14.47 10.47" />
                        </svg>
                    </button>
                </div>

                <button class="btn" type="submit">Login</button>

                <div class="muted">
                    비밀번호를 잊으셨나요? <a href="#">Reset</a>
                </div>
            </form>
        </div>
    </main>

    <script>
        // ===== 1) 비밀번호 표시 토글 =====
        const pw = document.getElementById('password');
        const toggle = document.getElementById('togglePw');
        const eyeOpen = document.getElementById('eyeOpen');
        const eyeClosed = document.getElementById('eyeClosed');
        const pwWrap = toggle.closest('.pw-wrap');

        toggle.addEventListener('click', () => {
            const showing = pw.type === 'password';
            pw.type = showing ? 'text' : 'password';
            eyeOpen.style.display = showing ? 'none' : 'inline';
            eyeClosed.style.display = showing ? 'inline' : 'none';
            pwWrap.classList.toggle('showing', showing);
            toggle.setAttribute('aria-pressed', String(showing));
            toggle.title = showing ? 'Hide password' : 'Show password';
        });

        // ===== 2) 마우스 위치에 따라 하이라이트 이동 =====
        const root = document.documentElement;
        let rafId = null;
        let targetX = 0.5, targetY = 0.5; // 0~1 정규화 좌표
        let curX = 0.5, curY = 0.5;

        function onPointerMove(e) {
            const w = window.innerWidth, h = window.innerHeight;
            const x = (e.clientX ?? (e.touches?.[0]?.clientX || w * 0.5)) / w;
            const y = (e.clientY ?? (e.touches?.[0]?.clientY || h * 0.5)) / h;
            targetX = x; targetY = y;
            if (!rafId) rafId = requestAnimationFrame(updateSpotlight);
        }
        function updateSpotlight() {
            // 부드러운 보간(이징)
            const k = 0.15;
            curX += (targetX - curX) * k;
            curY += (targetY - curY) * k;
            root.style.setProperty('--mx', (curX * 100).toFixed(2) + '%');
            root.style.setProperty('--my', (curY * 100).toFixed(2) + '%');

            if (Math.hypot(targetX - curX, targetY - curY) > 0.002) {
                rafId = requestAnimationFrame(updateSpotlight);
            } else {
                rafId = null;
            }
        }
        window.addEventListener('pointermove', onPointerMove, { passive: true });
        window.addEventListener('touchmove', onPointerMove, { passive: true });

        // ===== 3) 파티클 캔버스 (마우스 패럴랙스 & 느린 흐름) =====
        const canvas = document.getElementById('particles');
        const ctx = canvas.getContext('2d');
        let dpr = Math.min(window.devicePixelRatio || 1, 2); // 과도한 해상도 제한
        let W = 0, H = 0;

        function resize() {
            W = canvas.width = Math.floor(window.innerWidth * dpr);
            H = canvas.height = Math.floor(window.innerHeight * dpr);
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
        }
        window.addEventListener('resize', resize);
        resize();

        // 파티클 생성
        const COUNT = Math.floor((window.innerWidth * window.innerHeight) / 22000) + 40; // 화면 크기 비례
        const particles = [];
        for (let i = 0; i < COUNT; i++) {
            particles.push({
                x: Math.random() * W,
                y: Math.random() * H,
                r: (Math.random() * 1.8 + 0.6) * dpr,
                vx: (Math.random() - .5) * 0.15 * dpr,
                vy: (Math.random() - .5) * 0.15 * dpr,
                a: 0.35 + Math.random() * 0.65
            });
        }

        let lastTime = performance.now();
        function animate(t) {
            const dt = Math.min(32, t - lastTime); // ms
            lastTime = t;

            ctx.clearRect(0, 0, W, H);

            // 패럴랙스 오프셋(마우스에 살짝 끌려감)
            const parallaxX = (curX - 0.5) * 30 * dpr;
            const parallaxY = (curY - 0.5) * 30 * dpr;

            for (const p of particles) {
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // 느린 래핑(화면 밖으로 나가면 반대편에서 등장)
                if (p.x < -50) p.x = W + 50;
                if (p.x > W + 50) p.x = -50;
                if (p.y < -50) p.y = H + 50;
                if (p.y > H + 50) p.y = -50;

                ctx.globalAlpha = 0.25 * p.a;
                ctx.beginPath();
                // 하이라이트 중심 근처에서 밝기 살짝 상승
                const dx = p.x - (W * curX);
                const dy = p.y - (H * curY);
                const dist = Math.hypot(dx, dy);
                const glow = Math.max(0, 1 - dist / (220 * dpr));
                const base = 200 + Math.floor(glow * 55);
                ctx.fillStyle = `rgb(${base}, ${220}, ${255})`;
                ctx.arc(p.x + parallaxX * 0.6, p.y + parallaxY * 0.6, p.r, 0, Math.PI * 2);
                ctx.fill();
            }

            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
    </script>
</body>

</html>